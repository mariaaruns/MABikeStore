
@using System.Net.Http.Json
@using System.Threading

<div class="overflow-scroll">
<table class="table table-bordered table-responsive w-100">
     
    <thead>
        <tr>
        <th>Id</th>
    <th>Name </th>
    <th>City</th>
    <th>State</th>
    <th>Status</th>
    <th>Action</th>
        </tr>
    </thead>
    <tbody>
        <tr>
        <td>1</td>
        <td>store1 </td>
        <td>store2</td>
        <td>store3</td>
        <td>store4</td>
        <td>
                <MudButtonGroup Size="Size.Medium">
                        <MudFab Size="Size.Small" IconColor="Color.Primary" StartIcon="@Icons.Material.Filled.Edit" Color="Color.Primary" />
                        <MudFab Size="Size.Small" IconColor="Color.Primary" StartIcon="@Icons.Material.Filled.Delete" Color="Color.Secondary" />
                </MudButtonGroup>
        </td>
        </tr>
    </tbody>


</table>
</div>
@code {
    [Parameter]
    public string Status { get; set; }

    /// <summary>
    /// Here we simulate getting the paged, filtered and ordered data from the server, with a token for canceling this request
    /// </summary>
    // private async Task<TableData<Element>> ServerReload(TableState state, CancellationToken token)
    // {
    //     // Forward the provided token to methods which support it
    //     var data = await httpClient.GetFromJsonAsync<List<Element>>("webapi/periodictable", token);
    //     // Simulate a long-running operation
    //     await Task.Delay(300, token);
    //     // Get the total count
    //     var totalItems = data.Count();
    //     // Get the paged data
    //     var pagedData = data.Skip(state.Page * state.PageSize).Take(state.PageSize).ToList();
    //     // Return the data
    //     return new TableData<Element>() { TotalItems = totalItems, Items = pagedData };
    // }
}